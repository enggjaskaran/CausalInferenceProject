---
title: "STA 640 Final Project"
author: "Joon Sup Park, Jaskaran Singh"
date: '2022/04/17'
output: pdf_document
---

```{r setup, message=F, warning=F, echo=F}
library(tidyverse)
library(dplyr)
library(ggplot2)
library(glm2)
library(PSweight)
library(mvtnorm)
library(rje)
library(reshape2)
```

```{r}
#set.seed(1652)

generate_data <- function(n,p){
  W_mean = rep(0, p)
  W_var = diag(p)
  W = rmvnorm(n = n, mean = W_mean, sigma = W_var)
  return(W)
}

get_true_treatment <- function(W,n){
  theta = rep(c(-1, 0.5, -0.25, -0.1),dim(W)[2]/4)
  pi = expit(W %*% theta)
  Z = rbernoulli(n = n, p = pi)
  return (Z)
}

get_true_outcome <- function(n,W,Z){
  ATE_true = 20
  beta = c(210, rep(c(27.4, 13.7, 13.7, 13.7),dim(W)[2]/4), ATE_true)
  eps = rnorm(n = n, mean = 0, sd = 1)
  y = cbind(rep(1, n), W, Z) %*% beta + eps
  return (y)
}

get_ATE_true_PS <- function(df_T){
  glm_t = glm(formula = Z ~ 0 + ., family = binomial(link = "logit"), data = df_T %>% select(-c(y)))

  pi_pred_W = predict(glm_t, type = "response")

  ATE_PS_norm_T = sum(df_T$Z*df_T$y/pi_pred_W)/sum(df_T$Z/pi_pred_W) - 
  sum((1 - df_T$Z)*df_T$y/(1 - pi_pred_W))/sum((1 - df_T$Z)/(1 - pi_pred_W))
  
  output=list()
  output[[1]] <- pi_pred_W
  output[[2]] <- ATE_PS_norm_T
  return(output)
}

get_PO_true_model <- function(df_T){
  lm_y = lm(formula = y ~ 1 + ., data = df_T)
  lm_y_summ = summary(lm_y)
  y_coef = lm_y_summ$coefficients
  
  dimension <- dim(df_T)
  dim1 <- dim(df_T)[1]
  dim2 <- dim(df_T)[2]
  
  y0_pred_W <- as.matrix(cbind(const=as.matrix(rep(1,dim1),ncol=1),df_T[,2:(dim2-1)])) %*% as.matrix(y_coef[1:(dim2-1)], ncol=1)
  
  y1_pred_W = y0_pred_W + y_coef[dim2]
  
  output=list()
  output[[1]] <- y0_pred_W
  output[[2]] <- y1_pred_W
  return(output)
  }

get_transformed_data <- function(W,y,Z){
  X=data.frame()
  for(i in seq(from=1,to=dim(W)[2],by=4)){
    X = rbind(X,exp(W[,i]/2))
    X = rbind(X,W[, (i+1)]/(1 + exp(W[,i])) + 10)
    X = rbind(X,(W[,i]*W[,(i+2)]*25 + 0.6)^3)
    X = rbind(X,(W[,(i+1)] + W[,(i+3)] + 20)^2)
  }

  X = t(X)
  rownames(X)<-NULL
  df_F = data.frame(y, X, Z)
  return(df_F)
}

get_ATE_PS_false <- function(df_F){
  glm_t_F = glm(formula = Z ~ 0 + ., family = binomial(link = "logit"), data = df_F %>% select(-c(y)))

  pi_pred_X = predict(glm_t_F, type = "response")
  ATE_PS_norm_F = sum(df_F$Z*df_F$y/pi_pred_X)/sum(df_F$Z/pi_pred_X) -
  sum((1 - df_F$Z)*df_F$y/(1 - pi_pred_X))/sum((1 - df_F$Z)/(1 - pi_pred_X))
  
  output=list()
  output[[1]] <- pi_pred_X
  output[[2]] <- ATE_PS_norm_F
  return(output)
  }

get_PO_false_model <- function(df_F){
  lm_y_F = lm(formula = y ~ 1 + ., data = df_F)
  lm_y_F_summ = summary(lm_y_F)
  y_coef_F = lm_y_F_summ$coefficients

  dimension <- dim(df_F)
  dim1 <- dim(df_F)[1]
  dim2 <- dim(df_F)[2]
  
  y0_pred_X <-   as.matrix(cbind(data.frame(const=as.matrix(rep(1,dim1),ncol=1)),df_F[2:(dim2-1)])) %*% as.matrix(y_coef_F[1:(dim2-1)], ncol=1)
  
  y1_pred_X = y0_pred_X + y_coef_F[dim2]
  
  output=list()
  output[[1]] <- y0_pred_X
  output[[2]] <- y1_pred_X
  return(output)
}

get_DR_estimates <- function(n,y1_pred_W,y1_pred_X,y0_pred_W,y0_pred_X,pi_pred_W,pi_pred_X,df_T){
  ATE_double_TT = (1/n)*sum(y1_pred_W + df_T$Z*(df_T$y - y1_pred_W)/pi_pred_W) - 
  (1/n)*sum(y0_pred_W + (1 - df_T$Z)*(df_T$y - y0_pred_W)/(1 - pi_pred_W))
  
  ATE_double_TF = (1/n)*sum(y1_pred_W + df_T$Z*(df_T$y - y1_pred_W)/pi_pred_X) - 
  (1/n)*sum(y0_pred_W + (1 - df_T$Z)*(df_T$y - y0_pred_W)/(1 - pi_pred_X))
  
  ATE_double_FT = (1/n)*sum(y1_pred_X + df_T$Z*(df_T$y - y1_pred_X)/pi_pred_W) - 
  (1/n)*sum(y0_pred_X + (1 - df_T$Z)*(df_T$y - y0_pred_X)/(1 - pi_pred_W))
  
  ATE_double_FF = (1/n)*sum(y1_pred_X + df_T$Z*(df_T$y - y1_pred_X)/pi_pred_X) - 
  (1/n)*sum(y0_pred_X + (1 - df_T$Z)*(df_T$y - y0_pred_X)/(1 - pi_pred_X))
  
  output <- c(ATE_double_TT,ATE_double_TF,ATE_double_FT,ATE_double_FF)
  return(output)
}

get_DR_norm_estimates <- function(n,y1_pred_W,y1_pred_X,y0_pred_W,y0_pred_X,
                                  pi_pred_W,pi_pred_X,df_T){
  ATE_double_TT = (y1_pred_W + sum(df_T$Z*(df_T$y - y1_pred_W)/pi_pred_W)/
                     sum(df_T$Z/pi_pred_W)) - 
    (y0_pred_W + sum((1 - df_T$Z)*(df_T$y - y0_pred_W)/(1 - pi_pred_W))/
       sum(df_T$Z/(1 - pi_pred_W)))

  ATE_double_TF = (y1_pred_W + sum(df_T$Z*(df_T$y - y1_pred_W)/pi_pred_X)/
                     sum(df_T$Z/pi_pred_X)) - 
    (y0_pred_W + sum((1 - df_T$Z)*(df_T$y - y0_pred_W)/(1 - pi_pred_X))/
       sum(df_T$Z/(1 - pi_pred_X)))

  ATE_double_FT = (y1_pred_X + sum(df_T$Z*(df_T$y - y1_pred_X)/pi_pred_W)/
                     sum(df_T$Z/pi_pred_W)) - 
    (y0_pred_X + sum((1 - df_T$Z)*(df_T$y - y0_pred_X)/(1 - pi_pred_W))/
       sum(df_T$Z/(1 - pi_pred_W)))
  
  ATE_double_FF = (y1_pred_X + sum(df_T$Z*(df_T$y - y1_pred_X)/pi_pred_X)/
                     sum(df_T$Z/pi_pred_X)) - 
    (y0_pred_X + sum((1 - df_T$Z)*(df_T$y - y0_pred_X)/(1 - pi_pred_X))/
       sum(df_T$Z/(1 - pi_pred_X)))
  
  output <- c(ATE_double_TT,ATE_double_TF,ATE_double_FT,ATE_double_FF)
  return(output)
}


```

```{r}
runSimulation <- function(W,n){
  #W_1 = W[,1]
  #W_2 = W[,2]
  #W_3 = W[,3]
  #W_4 = W[,4]
  
  Z <- get_true_treatment(W,n)
  y <- get_true_outcome(n,W,Z)
  
  df_T = data.frame(y, W, Z)
  
  output <- get_ATE_true_PS(df_T)
  pi_pred_W <- output[[1]]
  ATE_PS_norm_T <- output[[2]]
  
  output <- get_PO_true_model(df_T)
  y0_pred_W <- output[[1]]
  y1_pred_W <- output[[2]]
  ATE_outcome_T = (1/n)*sum(Z*(y - y0_pred_W) + (1 - Z)*(y1_pred_W - y))
  
  df_F <- get_transformed_data(W,y,Z)
  output <- get_ATE_PS_false(df_F)
  pi_pred_X <- output[[1]]
  ATE_PS_norm_F <- output[[2]]
  
  output <- get_PO_false_model(df_F)
  y0_pred_X <- output[[1]]
  y1_pred_X <- output[[2]]
  
  ATE_outcome_F = (1/n)*sum(Z*(y - y0_pred_X) + (1 - Z)*(y1_pred_X - y))
  
  # output <- get_DR_estimates(n,y1_pred_W,y1_pred_X,y0_pred_W,y0_pred_X,pi_pred_W,pi_pred_X,df_T)

  output <- get_DR_norm_estimates(n,y1_pred_W,y1_pred_X,y0_pred_W,y0_pred_X,pi_pred_W,pi_pred_X,df_T)
  
  ATE_double_TT <- output[1]
  ATE_double_TF <- output[2]
  ATE_double_FT <- output[3]
  ATE_double_FF <- output[4]
  
  output_row <- c(ATE_PS_norm_T,ATE_outcome_T,ATE_PS_norm_F, ATE_outcome_F, 
                         ATE_double_TT, ATE_double_TF,ATE_double_FT,ATE_double_FF)
  return(output_row)
}

```

```{r}
get_ate_with_se <- function(nSimulations,nBootstrap,n,p){
  outputSim <- data.frame(matrix(ncol = 8, nrow = nSimulations))
  colnames(outputSim) <- c("ATE_PS_norm_T","ATE_outcome_T","ATE_PS_norm_F", "ATE_outcome_F", 
                         "ATE_double_TT", "ATE_double_TF","ATE_double_FT","ATE_double_FF")

  se_sim <- outputSim

  for (i in 1:nSimulations){
  W <- generate_data(n,p)
  output_row <- runSimulation(W,n)
  outputSim[i,] <- output_row
  
  bootstrap_samples <- matrix(ncol=8, nrow=nBootstrap)
  for(j in 1:nBootstrap){
    bootstraped_index <- sample(1:nrow(W), replace = TRUE)
    bootstraped_data <- W[bootstraped_index,]
    bootstrap_samples[j,] <- runSimulation(bootstraped_data,n)
  }
  se_sim[i,] <- sqrt(apply(bootstrap_samples,2,var))
  }
  
  output <- list()
  output[[1]] <- outputSim
  output[[2]] <- se_sim
  return(output)
}

```


```{r, warning=FALSE}
nSimulations <- 100
nBootstrap <- 100
p = 4

n_array <- c(30)

ate_df <- data.frame()
se_df <- data.frame()
  
for (i in 1:length(n_array)){
  print(c("doing.. ",i))
  n <- n_array[i]
  output <- get_ate_with_se(nSimulations,nBootstrap,n,p)
  ate_df <- rbind(ate_df,output[[1]] %>% mutate(n=n,p=p))
  se_df <- rbind(se_df,output[[2]] %>% mutate(n=n,p=p))
}


ate_df %>% group_by(n,p) %>% summarize(ATE_PS_norm_T=mean(ATE_PS_norm_T),
                                       ATE_outcome_T=mean(ATE_outcome_T),
                                       ATE_PS_norm_F=mean(ATE_PS_norm_F),
                                       ATE_outcome_F=mean(ATE_outcome_F),
                                       ATE_double_TT=mean(ATE_double_TT),
                                       ATE_double_TF=mean(ATE_double_TF),
                                       ATE_double_FT=mean(ATE_double_FT),
                                       ATE_double_FF=mean(ATE_double_FF)) %>% 
  melt(id=c("n","p"), variable.name="ATE") %>% 
  ggplot(aes(x=n,y=value,color=ATE)) +
  geom_line() + 
  labs(y="ATE", x="n: sample size")


se_df %>% group_by(n,p) %>% summarize(ATE_PS_norm_T=mean(ATE_PS_norm_T),
                                       ATE_outcome_T=mean(ATE_outcome_T),
                                       ATE_PS_norm_F=mean(ATE_PS_norm_F),
                                       ATE_outcome_F=mean(ATE_outcome_F),
                                       ATE_double_TT=mean(ATE_double_TT),
                                       ATE_double_TF=mean(ATE_double_TF),
                                       ATE_double_FT=mean(ATE_double_FT),
                                       ATE_double_FF=mean(ATE_double_FF)) %>% 
  melt(id=c("n","p"), variable.name="ATE") %>% 
  ggplot(aes(x=n,y=value,color=ATE)) +
  geom_line() + 
  labs(y="SE", x="n: sample size")


# saving RData files
ate_df_p8 <- ate_df
se_df_p8 <- se_df

save(se_df_p8, file = "se_df_p8.RData")
save(ate_df_p8, file = "ate_df_p8.RData")

load(file = "se_df_p8.RData")
load(file = "ate_df_p8.RData")
```

```{r, warning=FALSE}
for (i in 1:colnames(ate_df))

```



We first check our estimates of ATE via true PS model and true outcome model, consecutively.

```{r, warning = FALSE}
#set.seed(1652)


cat("The normalized ATE obtained via true PS model is", ATE_PS_norm_T, "with variance")
```

```{r}


df_check = data.frame(Z, y, y0_pred_W, y1_pred_W)



# for (s in 1:1000){
#   
# }

cat("The ATE obtained via true outcome model is", ATE_outcome_T, "which is the same as the coefficient on Z in the outcome model", lm_y_summ$coefficients[6], "with variance", lm_y_summ$cov.unscaled[6,6])
```

Note that both estimates are reasonably close to the true ATE, $\tau = 20$. Now we turn to the ATE estimates via false PS model and false outcome models, consecutively.

```{r}

```

```{r, warning = FALSE}
set.seed(1652)



cat("The normalized ATE obtained via false PS model is", ATE_PS_norm_F, "with variance \n")
cat("Comparing this with the normalized ATE obtained via true PS model", ATE_PS_norm_T, "we do not see so much deviation.")
```

```{r}




# for (s in 1:1000){
#   
# }

cat("The ATE obtained via false outcome model is", ATE_outcome_F, "\n")
cat("which is the same as the coefficient on Z in the outcome model", 
    lm_y_F_summ$coefficients[6], "with variance", lm_y_F_summ$cov.unscaled[6,6],
    "\n")
cat("Note that there is some deviation from the true ATE of", 20, "\n")
cat("and from the ATE obtained via true outcome model", ATE_outcome_T)
```

Now we take on doubly robust estimators for 4 possible cases: 1)true outcome model and true PS model; 2)true outcome model and false PS model; 3)false outcome model and true PS model; 4)false outcome model and false PS model

```{r, warning=FALSE}
  
cat("The doubly robust ATE obtained with true outcome model and true PS model is", ATE_double_TT, "\n")


  
cat("The doubly robust ATE obtained with true outcome model and false PS model is", ATE_double_TF, "\n")


  
cat("The doubly robust ATE obtained with false outcome model and true PS model is", ATE_double_FT, "\n")


  
cat("The doubly robust ATE obtained with false outcome model and false PS model is", ATE_double_FF, "\n")
```

